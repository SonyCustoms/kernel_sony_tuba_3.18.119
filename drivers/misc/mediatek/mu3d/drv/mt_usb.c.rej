--- drivers/misc/mediatek/mu3d/drv/mt_usb.c
+++ drivers/misc/mediatek/mu3d/drv/mt_usb.c
@@ -224,47 +220,121 @@ void mt_usb_disconnect(void)
 }
 EXPORT_SYMBOL_GPL(mt_usb_disconnect);
 
-bool usb_cable_connected(void)
+/* #define BYPASS_PMIC_LINKAGE */
+static CHARGER_TYPE mu3d_hal_get_charger_type(void)
 {
-	CHARGER_TYPE chg_type = CHARGER_UNKNOWN;
-	bool connected = false, vbus_exist = false;
-#if 0
-#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
-	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
-			|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT) {
-		os_printk(K_INFO, "%s, in KPOC, force USB on\n", __func__);
-		return true;
-	}
-#endif
-#endif
-#ifdef USB_FORCE_ON
-	/* FORCE USB ON */
-	chg_type = _mu3d_musb->charger_mode = STANDARD_HOST;
-	vbus_exist = true;
-	connected = true;
-	os_printk(K_INFO, "%s type force to STANDARD_HOST\n", __func__);
+	CHARGER_TYPE chg_type;
+#ifdef BYPASS_PMIC_LINKAGE
+	os_printk(K_INFO, "force on");
+	chg_type = STANDARD_HOST;
 #else
-	/* TYPE CHECK*/
-	chg_type = _mu3d_musb->charger_mode = mt_get_charger_type();
-	if (fake_CDP && chg_type == STANDARD_HOST) {
-		os_printk(K_INFO, "%s, fake to type 2\n", __func__);
-		chg_type = CHARGING_HOST;
-	}
+	chg_type = mt_get_charger_type();
+#endif
 
-	if (chg_type == STANDARD_HOST || chg_type == CHARGING_HOST)
-		connected = true;
+	return chg_type;
+}
+static bool mu3d_hal_is_vbus_exist(void)
+{
+	bool vbus_exist;
 
-	/* VBUS CHECK to avoid type miss-judge */
+#ifdef BYPASS_PMIC_LINKAGE
+	os_printk(K_INFO, "force on");
+	vbus_exist = true;
+#else
 #ifdef CONFIG_POWER_EXT
 	vbus_exist = upmu_get_rgs_chrdet();
 #else
 	vbus_exist = upmu_is_chr_det();
 #endif
-	os_printk(K_INFO, "%s vbus_exist=%d type=%d\n", __func__, vbus_exist, chg_type);
-	if (!vbus_exist)
-		connected = false;
 #endif
 
+	return vbus_exist;
+
+}
+
+static int mu3d_test_connect;
+static bool test_connected;
+static struct delayed_work mu3d_test_connect_work;
+#define TEST_CONNECT_BASE_MS 3000
+#define TEST_CONNECT_BIAS_MS 5000
+static void do_mu3d_test_connect_work(struct work_struct *work)
+{
+	static ktime_t ktime;
+	static unsigned long int ktime_us;
+	unsigned int delay_time_ms;
+
+	if (!mu3d_test_connect) {
+		test_connected = false;
+		os_printk(K_INFO, "%s, test done, trigger connect\n", __func__);
+		mt_usb_connect();
+		return;
+	}
+	mt_usb_connect();
+
+	ktime = ktime_get();
+	ktime_us = ktime_to_us(ktime);
+	delay_time_ms = TEST_CONNECT_BASE_MS + (ktime_us % TEST_CONNECT_BIAS_MS);
+	os_printk(K_INFO, "%s, work after %d ms\n", __func__, delay_time_ms);
+	schedule_delayed_work(&mu3d_test_connect_work, msecs_to_jiffies(delay_time_ms));
+
+	test_connected = !test_connected;
+}
+void mt_usb_connect_test(int start)
+{
+	static struct wake_lock device_test_wakelock;
+	static int wake_lock_inited;
+
+	if (!wake_lock_inited) {
+		os_printk(K_WARNIN, "%s wake_lock_init\n", __func__);
+		wake_lock_init(&device_test_wakelock, WAKE_LOCK_SUSPEND, "device.test.lock");
+		wake_lock_inited = 1;
+	}
+
+	if (start) {
+		wake_lock(&device_test_wakelock);
+		mu3d_test_connect = 1;
+		INIT_DELAYED_WORK(&mu3d_test_connect_work, do_mu3d_test_connect_work);
+		schedule_delayed_work(&mu3d_test_connect_work, 0);
+	} else {
+		mu3d_test_connect = 0;
+		wake_unlock(&device_test_wakelock);
+	}
+}
+
+bool usb_cable_connected(void)
+{
+	CHARGER_TYPE chg_type = CHARGER_UNKNOWN;
+	bool connected = false, vbus_exist = false;
+
+	if (mu3d_test_connect) {
+		os_printk(K_INFO, "%s, return test_connected<%d>\n", __func__, test_connected);
+		return test_connected;
+	}
+
+	if (mu3d_force_on) {
+		/* FORCE USB ON */
+		chg_type = _mu3d_musb->charger_mode = STANDARD_HOST;
+		vbus_exist = true;
+		connected = true;
+		os_printk(K_INFO, "%s type force to STANDARD_HOST\n", __func__);
+	} else {
+		/* TYPE CHECK*/
+		chg_type = _mu3d_musb->charger_mode = mu3d_hal_get_charger_type();
+		if (fake_CDP && chg_type == STANDARD_HOST) {
+			os_printk(K_INFO, "%s, fake to type 2\n", __func__);
+			chg_type = CHARGING_HOST;
+		}
+
+		if (chg_type == STANDARD_HOST || chg_type == CHARGING_HOST)
+			connected = true;
+
+		/* VBUS CHECK to avoid type miss-judge */
+		vbus_exist = mu3d_hal_is_vbus_exist();
+		os_printk(K_INFO, "%s vbus_exist=%d type=%d\n", __func__, vbus_exist, chg_type);
+		if (!vbus_exist)
+			connected = false;
+	}
+
 	/* CMODE CHECK */
 	if (cable_mode == CABLE_MODE_CHRG_ONLY || (cable_mode == CABLE_MODE_HOST_ONLY && chg_type != CHARGING_HOST))
 		connected = false;
