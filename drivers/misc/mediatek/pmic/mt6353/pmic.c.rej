--- drivers/misc/mediatek/pmic/mt6353/pmic.c
+++ drivers/misc/mediatek/pmic/mt6353/pmic.c
@@ -86,7 +86,6 @@
 #include "mt6311.h"
 #include <mach/mt_pmic.h>
 #include <mt-plat/mt_reboot.h>
-#include <mt-plat/mt_devinfo.h>
 
 /*wilma debug*/
 #include "include/pmic_efuse.h"
@@ -127,33 +126,6 @@ static DEFINE_MUTEX(pmic_access_mutex);
 /*--- Global suspend state ---*/
 static bool pmic_suspend_state;
 
-
-int pmic_chk_intf(void)
-{
-	struct task_struct *t, *p;
-	struct pid *pid;
-	int count = 0;
-	int ret = 0;
-
-	if (mutex_is_locked(&pmic_access_mutex)) {
-		pid = get_task_pid(pmic_access_mutex.owner, PIDTYPE_PID);
-		t = p = get_pid_task(pid, PIDTYPE_PID);
-		if (p != NULL) {
-			do {
-				if (t)
-					sched_show_task_local(t);
-					if ((++count)%5 == 4)
-						usleep_range(300, 500);
-			} while_each_thread(p, t);
-			put_task_struct(t);
-		}
-		put_pid(pid);
-		ret = 1;
-	} else
-		return 0;
-	return ret;
-}
-
 unsigned int pmic_read_interface(unsigned int RegNum, unsigned int *val, unsigned int MASK, unsigned int SHIFT)
 {
 	unsigned int return_value = 0;
@@ -162,11 +134,17 @@ unsigned int pmic_read_interface(unsigned int RegNum, unsigned int *val, unsigne
 	unsigned int pmic_reg = 0;
 	unsigned int rdata;
 
+	/*if ((pmic_suspend_state == true || !preemptible()) && irqs_disabled())*/
+	if (preempt_count() > 0 || irqs_disabled() || system_state != SYSTEM_RUNNING || oops_in_progress)
+		return pmic_read_interface_nolock(RegNum, val, MASK, SHIFT);
+	mutex_lock(&pmic_access_mutex);
+
 	/*mt_read_byte(RegNum, &pmic_reg);*/
 	return_value = pwrap_wacs2(0, (RegNum), 0, &rdata);
 	pmic_reg = rdata;
 	if (return_value != 0) {
 		PMICLOG("[pmic_read_interface] Reg[%x]= pmic_wrap read data fail\n", RegNum);
+		mutex_unlock(&pmic_access_mutex);
 		return return_value;
 	}
 	/*PMICLOG"[pmic_read_interface] Reg[%x]=0x%x\n", RegNum, pmic_reg);*/
@@ -175,6 +153,7 @@ unsigned int pmic_read_interface(unsigned int RegNum, unsigned int *val, unsigne
 	*val = (pmic_reg >> SHIFT);
 	/*PMICLOG"[pmic_read_interface] val=0x%x\n", *val);*/
 
+	mutex_unlock(&pmic_access_mutex);
 #else
 	/*PMICLOG("[pmic_read_interface] Can not access HW PMIC\n");*/
 #endif
@@ -245,7 +224,7 @@ unsigned int pmic_read_interface_nolock(unsigned int RegNum, unsigned int *val,
 
 #if defined(CONFIG_PMIC_HW_ACCESS_EN)
 	unsigned int pmic_reg = 0;
-	unsigned int rdata;
+	unsigned int rdata = 0;
 
 
 	/*mt_read_byte(RegNum, &pmic_reg); */
@@ -274,7 +253,7 @@ unsigned int pmic_config_interface_nolock(unsigned int RegNum, unsigned int val,
 
 #if defined(CONFIG_PMIC_HW_ACCESS_EN)
 	unsigned int pmic_reg = 0;
-	unsigned int rdata;
+	unsigned int rdata = 0;
 
     /* pmic wrapper has spinlock protection. pmic do not to do it again */
 
@@ -441,7 +420,12 @@ static ssize_t store_pmic_access(struct device *dev, struct device_attribute *at
 		pvalue = (char *)buf;
 		if (size > 5) {
 			addr = strsep(&pvalue, " ");
-			ret = kstrtou32(addr, 16, (unsigned int *)&reg_address);
+			if (addr != NULL)
+				ret = kstrtou32(addr, 16, (unsigned int *)&reg_address);
+			else {
+				pr_err("[store_pmic_access] addr is empty\n");
+				return -1;
+			}
 		} else
 			ret = kstrtou32(pvalue, 16, (unsigned int *)&reg_address);
 
@@ -449,11 +433,15 @@ static ssize_t store_pmic_access(struct device *dev, struct device_attribute *at
 			/*reg_value = simple_strtoul((pvalue + 1), NULL, 16);*/
 			/*pvalue = (char *)buf + 1;*/
 			val =  strsep(&pvalue, " ");
-			ret = kstrtou32(val, 16, (unsigned int *)&reg_value);
-
-			pr_err("[store_pmic_access] write PMU reg 0x%x with value 0x%x !\n",
-				reg_address, reg_value);
-			ret = pmic_config_interface(reg_address, reg_value, 0xFFFF, 0x0);
+			if (val != NULL) {
+				ret = kstrtou32(val, 16, (unsigned int *)&reg_value);
+				pr_err("[store_pmic_access] write PMU reg 0x%x with value 0x%x !\n",
+					reg_address, reg_value);
+				ret = pmic_config_interface(reg_address, reg_value, 0xFFFF, 0x0);
+			} else {
+				pr_err("[store_pmic_access] val is empty\n");
+				return -1;
+			}
 		} else {
 			ret = pmic_read_interface(reg_address, &g_reg_value, 0xFFFF, 0x0);
 			pr_err("[store_pmic_access] read PMU reg 0x%x with value 0x%x !\n",
@@ -700,18 +688,14 @@ static long pmic_ftm_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	int ret = 0;
 	int adc_in_data[2] = { 1, 1 };
 	int adc_out_data[2] = { 1, 1 };
-	unsigned int segment = get_devinfo_with_index(21) & 0xFF;
 
 	switch (cmd) {
 		/*#if defined(FTM_EXT_BUCK_CHECK)*/
 	case Get_IS_EXT_BUCK_EXIST:
 		user_data_addr = (int *)arg;
 		ret = copy_from_user(adc_in_data, user_data_addr, 8);
-		if (segment == 0x82 || segment == 0x86)
-			adc_out_data[0] = is_ext_buck_exist();
-		else if (segment == 0x41 || segment == 0x45 || segment == 0x40
-			|| segment == 0xC1 || segment == 0xC5)
-			adc_out_data[0] = is_ext_buck_gpio_exist();
+		/*adc_out_data[0] = is_ext_buck_exist();*/
+		adc_out_data[0] = is_ext_buck_gpio_exist();
 		ret = copy_to_user(user_data_addr, adc_out_data, 8);
 		PMICLOG("[pmic_ftm_ioctl] Get_IS_EXT_BUCK_EXIST:%d\n", adc_out_data[0]);
 		break;
@@ -972,7 +956,7 @@ static int pmic_mt_probe(struct platform_device *dev)
 	/* upmu_set_reg_value(0x2a6, 0xff); */ /* TBD */
 
 	/*pmic initial setting */
-#if defined(CONFIG_MTK_PMIC_CHIP_MT6353)
+#if 1
 	PMIC_INIT_SETTING_V1();
 	PMICLOG("[PMIC_INIT_SETTING_V1] Done\n");
 #else
@@ -1101,6 +1085,7 @@ static int __init pmic_mt_init(void)
 	wake_lock_init(&pmicThread_lock, WAKE_LOCK_SUSPEND, "pmicThread_lock_mt6328 wakelock");
 #endif
 
+	pmic_auxadc_init();
 #if !defined CONFIG_MTK_LEGACY
 /*#if !defined CONFIG_MTK_LEGACY*//*Jimmy*/
 #ifdef CONFIG_OF
@@ -1134,8 +1119,6 @@ static int __init pmic_mt_init(void)
 #endif				/* End of #if !defined CONFIG_MTK_LEGACY */
 
 
-	pmic_auxadc_init();
-
 	pr_debug("****[pmic_mt_init] Initialization : DONE !!\n");
 
 	return 0;
